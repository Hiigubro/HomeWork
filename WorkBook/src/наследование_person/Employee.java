package наследование_person;


/** extends
 * Чтобы объявить один класс наследником от другого,
 * надо использовать после имени класса-наследника
 * ключевое слово extends, после которого идет имя
 * базового класса.
 */
public class Employee extends Person{

    private String company;

    /** super
     * Если в базовом классе определены конструкторы,
     * то в конструкторе производного классы необходимо вызвать
     * один из конструкторов базового класса с помощью ключевого слова
     * super. Например, класс Person имеет конструктор, который принимает
     * один параметр. Поэтому в классе Employee в конструкторе нужно
     * вызвать констуктор класса Person. После слова super в скобках
     * идет перечисление передаваемых аргументов. Таким образом,
     * установка имени сотрудника делегируется
     * конструктору базового класса.
     * @param name
     * @param company
     */

    public Employee(String name, String company) {

        super(name);
        this.company = company;
    }

    /** @Override
     * Перед переопределяемым методом указывается аннотация @Override.
     * Данная аннотация в принципе необязательна.
     *
     * При переопределении метода он должен иметь уровень
     * доступа не меньше, чем уровень доступа в базовом класса.
     * Например, если в базовом классе метод имеет модификатор public,
     * то и в производном классе метод должен иметь модификатор public.
     */
    @Override
    public void display(){
        super.display();
        System.out.printf("Наниматель %s работает в %s \n", super.getName(), company);
    }

    public void work() {
        System.out.printf("%s работает в %s \n", getName(), company);
    }
}
